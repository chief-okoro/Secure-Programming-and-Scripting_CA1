# Ashley Okoro sba25350

import sys
import argparse
import requests
import re
import json
import time
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
from datetime import datetime
from typing import List, Dict, Tuple, Optional

# Try to import optional dependencies for enhanced functionality
try:
    from bs4 import BeautifulSoup
    BS4_AVAILABLE = True
except ImportError:
    BS4_AVAILABLE = False
    print("[WARNING] BeautifulSoup4 not installed. Form scanning will be limited.")

try:
    from cryptography.fernet import Fernet
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False
    print("[WARNING] Cryptography not installed. Results will not be encrypted.")



class ResultEncryption:


    def __init__(self):
        if CRYPTO_AVAILABLE:
            # In production, load this from a secure key management system
            self.key = Fernet.generate_key()
            self.cipher = Fernet(self.key)
            print(f"[INFO] Encryption enabled. Key (save securely): {self.key.decode()}")
        else:
            self.key = None
            self.cipher = None

    def encrypt_data(self, data: str) -> str:
       
        if self.cipher:
            try:
                encrypted = self.cipher.encrypt(data.encode())
                return encrypted.decode()
            except Exception as e:
                print(f"[ERROR] Encryption failed: {e}")
                return data
        return data

    def decrypt_data(self, encrypted_data: str) -> str:
   
        if self.cipher:
            try:
                decrypted = self.cipher.decrypt(encrypted_data.encode())
                return decrypted.decode()
            except Exception as e:
                print(f"[ERROR] Decryption failed: {e}")
                return encrypted_data
        return encrypted_data


# Common SQL injection payloads for detection testing
# These are designed to trigger SQL errors or boolean-based responses
SQL_INJECTION_PAYLOADS = [
    "' OR '1'='1",
    "' OR '1'='1' --",
    "' OR '1'='1' /*",
    "admin' --",
    "admin' #",
    "admin'/*",
    "' or 1=1--",
    "' or 1=1#",
    "' or 1=1/*",
    "') or ('1'='1",
    "1' OR '1'='1",
    "' UNION SELECT NULL--",
    "' AND 1=0 UNION ALL SELECT 'admin', 'password'--",
    "1' AND '1'='2",
]

# XSS testing payloads
XSS_PAYLOADS = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg/onload=alert('XSS')>",
    "javascript:alert('XSS')",
]

# Error patterns that indicate SQL injection vulnerability
SQL_ERROR_PATTERNS = [
    r"SQL syntax.*MySQL",
    r"Warning.*mysql_.*",
    r"MySQLSyntaxErrorException",
    r"valid MySQL result",
    r"PostgreSQL.*ERROR",
    r"Warning.*pg_.*",
    r"valid PostgreSQL result",
    r"Npgsql\.",
    r"Driver.*SQL[-_ ]*Server",
    r"OLE DB.*SQL Server",
    r"SQL Server.*Driver",
    r"Warning.*mssql_.*",
    r"Microsoft SQL Native Client",
    r"SQLServer JDBC Driver",
    r"Oracle error",
    r"Oracle.*Driver",
    r"Warning.*oci_.*",
    r"Warning.*ora_.*",
]

class WebVulnerabilityScanner:
  
    def __init__(self, target_url: str, deep_scan: bool = False):
    
        self.target_url = target_url
        self.deep_scan = deep_scan
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Security Scanner/1.0)'
        })
        self.vulnerabilities = []
        self.encryption = ResultEncryption()

        # Validate target URL
        parsed = urlparse(target_url)
        if not parsed.scheme or not parsed.netloc:
            raise ValueError("Invalid URL. Must include protocol (http:// or https://)")

    def log_vulnerability(self, vuln_type: str, severity: str,
                         description: str, evidence: str = ""):
      
        # Encrypt sensitive evidence data
        encrypted_evidence = self.encryption.encrypt_data(evidence) if evidence else ""

        vulnerability = {
            'timestamp': datetime.now().isoformat(),
            'type': vuln_type,
            'severity': severity,
            'description': description,
            'evidence_encrypted': encrypted_evidence,
            'target': self.target_url
        }
        self.vulnerabilities.append(vulnerability)

        # Display to console (without sensitive evidence)
        severity_markers = {
            'LOW': '[+]',
            'MEDIUM': '[!]',
            'HIGH': '[!!]',
            'CRITICAL': '[!!!]'
        }
        marker = severity_markers.get(severity, '[?]')
        print(f"{marker} {severity} - {vuln_type}: {description}")

    def test_sql_injection_url(self) -> None:
    
        print("Testing for SQL Injection in URL parameters...")

        parsed_url = urlparse(self.target_url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
        params = parse_qs(parsed_url.query)

        if not params:
            print("[INFO] No URL parameters found to test.")
            return

        # Get baseline response for comparison
        try:
            baseline_response = self.session.get(self.target_url, timeout=10)
            baseline_length = len(baseline_response.text)
        except requests.RequestException as e:
            print(f"[ERROR] Failed to get baseline response: {e}")
            return

        # Test each parameter with SQL injection payloads
        for param_name, param_values in params.items():
            print(f" Testing parameter: {param_name}")

            for payload in SQL_INJECTION_PAYLOADS:
                # Create modified parameters with payload
                test_params = params.copy()
                test_params[param_name] = [payload]

                # Build test URL
                test_url = f"{base_url}?{urlencode(test_params, doseq=True)}"

                try:
                    # Send request with injected payload
                    response = self.session.get(test_url, timeout=10)
                    response_text = response.text

                    # Check for SQL error patterns in response
                    for error_pattern in SQL_ERROR_PATTERNS:
                        if re.search(error_pattern, response_text, re.IGNORECASE):
                            self.log_vulnerability(
                                vuln_type="SQL Injection",
                                severity="HIGH",
                                description=f"SQL error detected in parameter '{param_name}'",
                                evidence=f"Payload: {payload}\nURL: {test_url}\nError pattern matched: {error_pattern}"
                            )
                            break

                    # Check for boolean-based SQL injection
                    # Significant difference in response length may indicate vulnerability
                    if abs(len(response_text) - baseline_length) > 500:
                        self.log_vulnerability(
                            vuln_type="SQL Injection (Boolean-based)",
                            severity="MEDIUM",
                            description=f"Possible boolean-based SQL injection in '{param_name}'",
                            evidence=f"Payload: {payload}\nResponse length difference: {abs(len(response_text) - baseline_length)} bytes"
                        )

                except requests.RequestException:
                    # Connection errors may indicate WAF blocking or network issues
                    pass

                # Rate limiting to avoid overwhelming the target
                time.sleep(0.5)

    def test_sql_injection_forms(self) -> None:
  
        if not BS4_AVAILABLE:
            print("[SKIP] Form testing requires BeautifulSoup4.")
            return

        print("\n Testing for SQL Injection in forms...")

        try:
            # Fetch the target page
            response = self.session.get(self.target_url, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')

            # Find all forms on the page
            forms = soup.find_all('form')

            if not forms:
                print("[INFO] No forms found on target page.")
                return

            print(f"[INFO] Found {len(forms)} form(s) to test.")

            # Test each form
            for form_idx, form in enumerate(forms):
                print(f" Testing form {form_idx + 1}/{len(forms)}")

                # Extract form action and method
                action = form.get('action', '')
                method = form.get('method', 'get').lower()
                form_url = urljoin(self.target_url, action)

                # Extract all input fields
                inputs = form.find_all(['input', 'textarea', 'select'])

                # Test with SQL injection payloads
                for payload in SQL_INJECTION_PAYLOADS[:5]:  # Limit payloads for forms
                    form_data = {}

                    # Populate form fields
                    for input_tag in inputs:
                        input_name = input_tag.get('name')
                        input_type = input_tag.get('type', 'text')

                        if not input_name:
                            continue

                        # Inject payload into text-based fields
                        if input_type in ['text', 'search', 'email', 'password']:
                            form_data[input_name] = payload
                        elif input_type == 'hidden':
                            form_data[input_name] = input_tag.get('value', '')
                        else:
                            form_data[input_name] = 'test'

                    try:
                        # Submit the form with injected payload
                        if method == 'post':
                            form_response = self.session.post(form_url, data=form_data, timeout=10)
                        else:
                            form_response = self.session.get(form_url, params=form_data, timeout=10)

                        # Check for SQL errors in response
                        for error_pattern in SQL_ERROR_PATTERNS:
                            if re.search(error_pattern, form_response.text, re.IGNORECASE):
                                self.log_vulnerability(
                                    vuln_type="SQL Injection (Form)",
                                    severity="HIGH",
                                    description=f"SQL error in form submission at {form_url}",
                                    evidence=f"Payload: {payload}\nForm data: {json.dumps(form_data)}"
                                )
                                break

                    except requests.RequestException:
                        pass

                    time.sleep(0.5)

        except requests.RequestException as e:
            print(f"[ERROR] Failed to test forms: {e}")

    def test_xss(self) -> None:
       

        parsed_url = urlparse(self.target_url)
        params = parse_qs(parsed_url.query)

        if not params:
            print("[INFO] No URL parameters found for XSS testing.")
            return

        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"

        for param_name in params.keys():
            for payload in XSS_PAYLOADS:
                test_params = params.copy()
                test_params[param_name] = [payload]
                test_url = f"{base_url}?{urlencode(test_params, doseq=True)}"

                try:
                    response = self.session.get(test_url, timeout=10)

                    # Check if payload is reflected without encoding
                    if payload in response.text:
                        self.log_vulnerability(
                            vuln_type="Cross-Site Scripting (XSS)",
                            severity="HIGH",
                            description=f"Reflected XSS in parameter '{param_name}'",
                            evidence=f"Payload: {payload}\nURL: {test_url}"
                        )

                except requests.RequestException:
                    pass

                time.sleep(0.5)

    def check_security_headers(self) -> None:
       
        print("Checking security headers...")

        try:
            response = self.session.get(self.target_url, timeout=10)
            headers = response.headers

            # Critical security headers
            security_headers = {
                'X-Frame-Options': 'Protects against clickjacking attacks',
                'X-Content-Type-Options': 'Prevents MIME sniffing',
                'Strict-Transport-Security': 'Enforces HTTPS connections',
                'Content-Security-Policy': 'Mitigates XSS and injection attacks',
            }

            for header, purpose in security_headers.items():
                if header not in headers:
                    self.log_vulnerability(
                        vuln_type="Missing Security Header",
                        severity="MEDIUM",
                        description=f"Missing {header} header",
                        evidence=f"Purpose: {purpose}"
                    )

            # Check for insecure header values
            if 'X-Powered-By' in headers:
                self.log_vulnerability(
                    vuln_type="Information Disclosure",
                    severity="LOW",
                    description="X-Powered-By header reveals server technology",
                    evidence=f"Value: {headers['X-Powered-By']}"
                )

        except requests.RequestException as e:
            print(f"[ERROR] Failed to check security headers: {e}")

    def scan(self) -> Dict:
       
        print(f"Web Vulnerability Scanner")
        print(f"Target: {self.target_url}")
        print(f"Scan Type: {'Deep Scan' if self.deep_scan else 'Standard Scan'}")
        print(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        # Execute all vulnerability tests
        self.test_sql_injection_url()
        self.test_sql_injection_forms()
        self.test_xss()
        self.check_security_headers()

        # Generate summary
        print(f"Scan Complete")

        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        for vuln in self.vulnerabilities:
            severity_counts[vuln['severity']] += 1

        print(f"Total Vulnerabilities: {len(self.vulnerabilities)}")
        print(f"  Critical: {severity_counts['CRITICAL']}")
        print(f"  High: {severity_counts['HIGH']}")
        print(f"  Medium: {severity_counts['MEDIUM']}")
        print(f"  Low: {severity_counts['LOW']}")

        return {
            'target': self.target_url,
            'scan_type': 'deep' if self.deep_scan else 'standard',
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': self.vulnerabilities,
            'summary': severity_counts
        }

    def save_report(self, filename: str = None) -> None:
   
        if filename is None:
            filename = f"scan_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        report_data = {
            'target': self.target_url,
            'scan_type': 'deep' if self.deep_scan else 'standard',
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': self.vulnerabilities,
            'encryption_key': self.encryption.key.decode() if self.encryption.key else None
        }

        try:
            with open(filename, 'w') as f:
                json.dump(report_data, f, indent=2)
            print(f"\n[+] Report saved to: {filename}")
        except IOError as e:
            print(f"[ERROR] Failed to save report: {e}")



def main():

    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description='Web Vulnerability Scanner - Defensive Security Tool',
        epilog='Example: python web_vulnerability_scanner.py --url https://example.com'
    )

    parser.add_argument(
        '--url',
        required=True,
        help='Target URL to scan (must include http:// or https://)'
    )

    parser.add_argument(
        '--deep',
        action='store_true',
        help='Enable deep scan mode (more comprehensive but slower)'
    )

    parser.add_argument(
        '--output',
        help='Output filename for scan report (JSON format)'
    )

    args = parser.parse_args()

    # Validate URL format
    if not args.url.startswith(('http://', 'https://')):
        print("[ERROR] URL must start with http:// or https://")
        sys.exit(1)

    try:
        # Initialize and run scanner
        scanner = WebVulnerabilityScanner(args.url, deep_scan=args.deep)
        scanner.scan()

        # Save report
        scanner.save_report(args.output)

    except ValueError as e:
        print(f"[ERROR] {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n[!] Scan interrupted by user.")
        sys.exit(130)
    except Exception as e:
        print(f"[ERROR] Unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
